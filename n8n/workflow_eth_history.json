{
  "name": "Sentinel ETH History Sync (Full History)",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 15
            }
          ]
        }
      },
      "name": "Manual/Schedule Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.1,
      "position": [
        250,
        300
      ]
    },
    {
      "parameters": {
        "url": "https://api.coingecko.com/api/v3/coins/ethereum/market_chart",
        "options": {},
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-cg-demo-api-key",
              "value": "CG-unVU5nDtud2jHLq8eBU1shZ2"
            }
          ]
        },
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "vs_currency",
              "value": "usd"
            },
            {
              "name": "days",
              "value": "3650"
            },
            {
              "name": "interval",
              "value": "daily"
            }
          ]
        }
      },
      "name": "CoinGecko API (ETH Max)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        450,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "function calculateSMA(prices,period){if(prices.length<period)return null;const slice=prices.slice(-period);return slice.reduce((a,b)=>a+b,0)/period}function calculateRSI(prices,period=14){if(prices.length<period+1)return null;let gains=0;let losses=0;for(let i=prices.length-period;i<prices.length;i++){const diff=prices[i]-prices[i-1];if(diff>0)gains+=diff;else losses-=diff}const avgGain=gains/period;const avgLoss=losses/period;if(avgLoss===0)return 100;const rs=avgGain/avgLoss;return 100-(100/(1+rs))}function calculateBollingerBands(prices,period=20,stdDev=2){if(prices.length<period)return{upper:null,lower:null};const slice=prices.slice(-period);const sma=slice.reduce((a,b)=>a+b,0)/period;const variance=slice.reduce((a,b)=>a+Math.pow(b-sma,2),0)/period;const std=Math.sqrt(variance);return{upper:sma+(stdDev*std),lower:sma-(stdDev*std)}}function processMarketData(items){const rawData=items[0].json;const priceData=rawData.prices||[];if(priceData.length===0){throw new Error('No price data received from CoinGecko API')}const closePrices=[];let maxPrice=0;const results=[];for(const[timestamp,price]of priceData){closePrices.push(price);if(price>maxPrice)maxPrice=price;const date=new Date(timestamp).toISOString().split('T')[0];const sma50=calculateSMA(closePrices,50);const sma200=calculateSMA(closePrices,200);const rsi=calculateRSI(closePrices,14);const{upper:bbUpper,lower:bbLower}=calculateBollingerBands(closePrices,20,2);const drawdownPct=((price-maxPrice)/maxPrice)*100;results.push({date,close:Math.round(price*100)/100,open:Math.round(price*100)/100,high:Math.round(price*100)/100,low:Math.round(price*100)/100,volume:0,sma_50:sma50?Math.round(sma50*100)/100:null,sma_200:sma200?Math.round(sma200*100)/100:null,rsi:rsi?Math.round(rsi*100)/100:null,bb_upper:bbUpper?Math.round(bbUpper*100)/100:null,bb_lower:bbLower?Math.round(bbLower*100)/100:null,drawdown_pct:Math.round(drawdownPct*100)/100})}return results;}return $input.all().map(item=>{const processedData=processMarketData($input.all());return processedData.map(row=>({json:row}))}).flat();"
      },
      "name": "Calculate Indicators",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        650,
        300
      ]
    },
    {
      "parameters": {
        "command": "=node -e '\nconst https = require(\"https\");\nconst inputData = JSON.parse(process.argv[1]);\n// Supabase limits batch size, so we split it\nconst BATCH_SIZE = 100;\nconst batches = [];\nfor (let i = 0; i < inputData.length; i += BATCH_SIZE) {\n    batches.push(inputData.slice(i, i + BATCH_SIZE));\n}\n\nasync function uploadBatch(batch, index) {\n    return new Promise((resolve, reject) => {\n        const payload = JSON.stringify(batch);\n        const options = {\n            hostname: \"uzxocjwuisgzldbtppnk.supabase.co\",\n            path: \"/rest/v1/ethereum_data\",\n            method: \"POST\",\n            headers: {\n                \"apikey\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc2ODEyNTA2MywiZXhwIjoyMDgzNzAxMDYzfQ.xMKopVQ2t-QkXgLKWBvTYim7QuJIv0ulzuT_xA5EpV8\",\n                \"Authorization\": \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc2ODEyNTA2MywiZXhwIjoyMDgzNzAxMDYzfQ.xMKopVQ2t-QkXgLKWBvTYim7QuJIv0ulzuT_xA5EpV8\",\n                \"Content-Type\": \"application/json\",\n                \"Prefer\": \"resolution=merge-duplicates\",\n                \"Content-Length\": Buffer.byteLength(payload)\n            }
        };

        const req = https.request(options, (res) => {\n            let responseBody = \"\";\n            res.on(\"data\", (chunk) => responseBody += chunk);\n            res.on(\"end\", () => {\n                if (res.statusCode >= 200 && res.statusCode < 300) {\n                    console.log(`Batch ${index + 1}/${batches.length} Success`);\n                    resolve();\n                } else {\n                    console.error(`Batch ${index + 1} Failed: ${res.statusCode} ${responseBody}`);\n                    reject(new Error(`Status ${res.statusCode}`));\n                }\n            });\n        });\n
        req.on("error", (e) => reject(e));\n        req.write(payload);\n        req.end();\n    });\n}\n
async function run() {\n    console.log(`Uploading ${inputData.length} records...`);\n    for (let i = 0; i < batches.length; i++) {\n        await uploadBatch(batches[i], i);\n    }\n}\n
run().catch(err => { console.error(err); process.exit(1); });\n' '{{JSON.stringify($json)}}'"
      },
      "name": "Upsert Batch to Supabase",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        850,
        300
      ]
    }
  ],
  "connections": {
    "Manual/Schedule Trigger": {
      "main": [
        [
          {
            "node": "CoinGecko API (ETH Max)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CoinGecko API (ETH Max)": {
      "main": [
        [
          {
            "node": "Calculate Indicators",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Indicators": {
      "main": [
        [
          {
            "node": "Upsert Batch to Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  }
}